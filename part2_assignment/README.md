# Assignment 2: Factory Steady State & Bounded Belts - Design Notes

This document details the modeling choices, algorithms, and implementation details for the `factory` and `belts` command-line tools.

## Part A: Factory Steady State (`factory`)

### 1. Factory Modeling Choices

* **Core Model**: The problem is modeled as a **Linear Programming (LP)** problem. The goal is to find a set of non-negative "crafts per minute" ($x_r$) for each recipe $r$ that satisfies all constraints.
* **Solver**: The `PuLP` Python library is used to build the model, and it interfaces with the **CBC (COIN-OR Branch and Cut)** solver, which is a fast, robust, and deterministic open-source LP solver.

### 2. Constraint Implementation

* **Item Balance / Conservation**: For each item $i$, a single balance equation is created:
    `Sum(Production_i) - Sum(Consumption_i) = b_i`
    * **Target Item**: `b_i` is set to the exact `target_rate` (an equality constraint `==`).
    * **Intermediates**: `b_i` is set to `0` (an equality constraint `== 0`) to enforce a perfect steady state.
    * **Raw Items**: `b_i` is constrained to be non-positive (`<= 0`), ensuring they are only consumed, not produced.
* **Raw Consumption**: A second constraint is added for raw items. The net consumption (which is `-b_i`) is constrained to be less than or equal to the supply cap: `-b_i <= raw_cap_i`.
* **Machine Capacity**: For each machine type $m$, a single constraint is created:
    `Sum(machines_used_by_r) <= max_machines_m`
    Where `machines_used_by_r` is `x_r * (1.0 / eff_crafts_per_min(r))`.
* **Module Application**: Module effects (speed and productivity) are pre-calculated before building the LP.
    * `eff_crafts_per_min(r)`: This constant is pre-computed using the machine's base speed, the speed module, and the recipe time.
    * `prod_multiplier(r)`: This constant (`1 + prod_mod`) is pre-computed and used as a coefficient in the item balance equations for all of the recipe's outputs.

### 3. Handling Cycles, Byproducts, and Ties

* **Cycles & Byproducts**: The LP formulation naturally handles these cases. A cycle or a byproduct is just an intermediate item. By enforcing its steady-state balance (`b_i == 0`), the solver finds the correct flow rates to keep the cycle balanced.
* **Tie-Breaking**: The primary objective is to minimize total machines. To handle ties for the minimum machine count, a secondary, weighted objective is added. The `crafts_per_min` ($x_r$) for each recipe are added to the objective function, each multiplied by a very small, exponentially decreasing weight (`epsilon^k`). This ensures that the solver prefers the solution that is lexicographically smallest on the (alphabetically sorted) recipe craft rates, without ever outweighing the primary goal of minimizing machines.

### 4. Infeasibility Detection

The solution uses a two-phase approach:

1.  **Phase 1 (Optimization)**: First, we attempt to solve the LP with the objective of **minimizing machines** and the constraint `target_rate == requested_rate`.
2.  **Phase 2 (Max Rate)**:
    * If Phase 1 fails (is "Infeasible"), it means the `requested_rate` is impossible.
    * We then formulate and solve a *new* LP. The objective is changed to **maximize `T`**, where `T` is a new LP variable. The target balance constraint is changed to `balance_target == T`.
    * The result of this second LP is the `max_feasible_target_per_min`.
    * **Bottleneck Hints** are generated by inspecting the `slack` on the constraints of this *second* LP. Any `Raw_Supply_Cap` or `Machine_Cap` constraint with a slack near zero (e.g., `< 1e-9`) was a limiting factor and is reported as a hint.

---

## Part B: Belts (`belts`)

### 1. Belts Modeling Choices

* **Core Model**: The problem is modeled as a **Maximum Flow** problem , specifically a "feasibility check for circulation with demands".
* **Solver**: The `NetworkX` library is used to build the graph and find the maximum flow using its `maximum_flow` (preflow-push) algorithm.

### 2. Transformation Steps

The graph described in the input is transformed into a single standard $s-t$ max-flow problem:

1.  **Node-Splitting**: Any node `v` with a `cap(v)` (that isn't a source or sink) is split into two nodes, `v_IN` and `v_OUT`. An edge `(v_IN, v_OUT)` is added with `capacity = cap(v)`.
2.  **Edge Transformation**: An edge `(u, v)` with bounds `[lo, hi]` is transformed into a new edge `(map_out(u), map_in(v))` with `capacity = hi - lo`.
3.  **Imbalance Calculation**: An "imbalance" `b(v)` is calculated for each *original* node `v` based *only on the lower bounds*:
    `b(v) = sum(lo_in_to_v) - sum(lo_out_from_v)`
4.  **Super-Nodes**: A single super-source (`s*`) and super-sink (`t*`) are created.
5.  **Connecting the Graph**:
    * **Lower Bounds**: For each node `v` with imbalance `b(v)`:
        * If `b(v) > 0` (node `v` *needs* `b(v)` flow), add edge `(s*, map_in(v))` with `capacity = b(v)`.
        * If `b(v) < 0` (node `v` *has* `b(v)` flow), add edge `(map_out(v), t*)` with `capacity = -b(v)`.
    * **Main Supply**: For each original source `s` with `supply(s)`, add edge `(s*, map_out(s))` with `capacity = supply(s)`.
    * **Main Demand**: For the original sink `t`, add edge `(map_in(t), t*)` with `capacity = total_supply`.
6.  **Demand Calculation**: We sum all capacities on all edges leaving `s*` to get a `total_demand_to_meet`.

### 3. Feasibility & Infeasibility

* **Feasibility Check**: A single max-flow is run from `s*` to `t*`. The flow is **feasible if and only if** the resulting `max_flow` value is equal (within tolerance) to the `total_demand_to_meet`. This single check validates all lower bounds, node caps, and supply/demand at once.
* **Infeasibility Certificate**: If the flow is less than the demand, the problem is infeasible.
    * A **min-cut** is computed on the graph using `nx.minimum_cut`.
    * The `cut_reachable` set is the set of nodes reachable from `s*` in the residual graph (one side of the partition).
    * The `deficit` is `total_demand_to_meet - max_flow`.

### 4. Flow Reconstruction

If feasible, the flow on an original edge `(u, v)` is `f' + lo`, where `lo` is the original lower bound and `f'` is the flow on the transformed edge `(map_out(u), map_in(v))` found by the `maximum_flow` algorithm.

---

## Numeric Approach & Edge Cases

* **Numeric Tolerance**: A standard tolerance of `1e-9` is used for all floating-point comparisons, such as checking LP constraint slacks, flow feasibility, and intermediate item balance.
* **Determinism**: Determinism is guaranteed by the underlying solvers. `pulp`'s default `CBC` solver is deterministic. `networkx`'s `maximum_flow` and `minimum_cut` algorithms are also deterministic.
* **Failure Modes**:
    * **Infeasible Raw Supplies**: `factory` will be "Infeasible" and the `find_max_rate` LP will identify the tight raw supply constraint as a bottleneck.
    * **Redundant Recipes**: The `factory` LP will *automatically* choose the most machine-efficient recipe(s) due to the "minimize total machines" objective.
    * **Disconnected Graph (Belts)**: If a source cannot reach the sink, its required flow won't be met. The `s*` to `t*` flow will not saturate, and the `min-cut` will correctly identify the disconnected component as the source-side of the cut.
