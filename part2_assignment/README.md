# Assignment 2: Factory Steady State & Bounded Belts - Design Notes

This document details the modeling choices, algorithms, and implementation details for the `factory` and `belts` command-line tools.

## Part A: Factory Steady State (`factory`)

### 1. Factory Modeling Choices

* [cite_start]**Core Model**: The problem is modeled as a **Linear Programming (LP)** problem[cite: 66]. [cite_start]The goal is to find a set of non-negative "crafts per minute" ($x_r$) for each recipe $r$ that satisfies all constraints[cite: 16].
* **Solver**: The `PuLP` Python library is used to build the model, and it interfaces with the **CBC (COIN-OR Branch and Cut)** solver, which is a fast, robust, and deterministic open-source LP solver.

### 2. Constraint Implementation

* **Item Balance / Conservation**: For each item $i$, a single balance equation is created:
    [cite_start]`Sum(Production_i) - Sum(Consumption_i) = b_i` [cite: 42]
    * [cite_start]**Target Item**: `b_i` is set to the exact `target_rate` (an equality constraint `==`)[cite: 44].
    * [cite_start]**Intermediates**: `b_i` is set to `0` (an equality constraint `== 0`) to enforce a perfect steady state[cite: 45].
    * [cite_start]**Raw Items**: `b_i` is constrained to be non-positive (`<= 0`), ensuring they are only consumed, not produced[cite: 47].
* **Raw Consumption**: A second constraint is added for raw items. [cite_start]The net consumption (which is `-b_i`) is constrained to be less than or equal to the supply cap: `-b_i <= raw_cap_i`[cite: 47].
* **Machine Capacity**: For each machine type $m$, a single constraint is created:
    [cite_start]`Sum(machines_used_by_r) <= max_machines_m` [cite: 58]
    [cite_start]Where `machines_used_by_r` is `x_r * (1.0 / eff_crafts_per_min(r))`[cite: 56].
* [cite_start]**Module Application**: Module effects (speed and productivity) are pre-calculated before building the LP[cite: 26, 36].
    * [cite_start]`eff_crafts_per_min(r)`: This constant is pre-computed using the machine's base speed, the speed module, and the recipe time[cite: 35].
    * [cite_start]`prod_multiplier(r)`: This constant (`1 + prod_mod`) is pre-computed and used as a coefficient in the item balance equations for all of the recipe's outputs[cite: 39].

### 3. Handling Cycles, Byproducts, and Ties

* [cite_start]**Cycles & Byproducts**: The LP formulation naturally handles these cases[cite: 51]. A cycle or a byproduct is just an intermediate item. By enforcing its steady-state balance (`b_i == 0`), the solver finds the correct flow rates to keep the cycle balanced.
* [cite_start]**Tie-Breaking**: The primary objective is to minimize total machines[cite: 61]. To handle ties for the minimum machine count, a secondary, weighted objective is added. The `crafts_per_min` ($x_r$) for each recipe are added to the objective function, each multiplied by a very small, exponentially decreasing weight (`epsilon^k`). [cite_start]This ensures that the solver prefers the solution that is lexicographically smallest on the (alphabetically sorted) recipe craft rates[cite: 161], without ever outweighing the primary goal of minimizing machines.

### 4. Infeasibility Detection

[cite_start]The solution uses a two-phase approach[cite: 63, 259]:

1.  **Phase 1 (Optimization)**: First, we attempt to solve the LP with the objective of **minimizing machines** and the constraint `target_rate == requested_rate`.
2.  **Phase 2 (Max Rate)**:
    * [cite_start]If Phase 1 fails (is "Infeasible"), it means the `requested_rate` is impossible[cite: 22].
    * We then formulate and solve a *new* LP. The objective is changed to **maximize `T`**, where `T` is a new LP variable. The target balance constraint is changed to `balance_target == T`.
    * [cite_start]The result of this second LP is the `max_feasible_target_per_min`[cite: 89].
    * **Bottleneck Hints** are generated by inspecting the `slack` on the constraints of this *second* LP. [cite_start]Any `Raw_Supply_Cap` or `Machine_Cap` constraint with a slack near zero (e.g., `< 1e-9`) was a limiting factor and is reported as a hint[cite: 90].

---

## Part B: Belts (`belts`)

### 1. Belts Modeling Choices

* [cite_start]**Core Model**: The problem is modeled as a **Maximum Flow** problem [cite: 169][cite_start], specifically a "feasibility check for circulation with demands"[cite: 185, 190].
* **Solver**: The `NetworkX` library is used to build the graph and find the maximum flow using its `maximum_flow` (preflow-push) algorithm.

### 2. Transformation Steps

The graph described in the input is transformed into a single standard $s-t$ max-flow problem:

1.  **Node-Splitting**: Any node `v` with a `cap(v)` (that isn't a source or sink) is split into two nodes, `v_IN` and `v_OUT`. [cite_start]An edge `(v_IN, v_OUT)` is added with `capacity = cap(v)` [cite: 181-184].
2.  [cite_start]**Edge Transformation**: An edge `(u, v)` with bounds `[lo, hi]` is transformed into a new edge `(map_out(u), map_in(v))` with `capacity = hi - lo`[cite: 187].
3.  [cite_start]**Imbalance Calculation**: An "imbalance" `b(v)` is calculated for each *original* node `v` based *only on the lower bounds*[cite: 188]:
    `b(v) = sum(lo_in_to_v) - sum(lo_out_from_v)`
4.  [cite_start]**Super-Nodes**: A single super-source (`s*`) and super-sink (`t*`) are created[cite: 191].
5.  **Connecting the Graph**:
    * **Lower Bounds**: For each node `v` with imbalance `b(v)`:
        * If `b(v) > 0` (node `v` *needs* `b(v)` flow), add edge `(s*, map_in(v))` with `capacity = b(v)`.
        * If `b(v) < 0` (node `v` *has* `b(v)` flow), add edge `(map_out(v), t*)` with `capacity = -b(v)`.
    * [cite_start]**Main Supply**: For each original source `s` with `supply(s)`, add edge `(s*, map_out(s))` with `capacity = supply(s)`[cite: 193].
    * [cite_start]**Main Demand**: For the original sink `t`, add edge `(map_in(t), t*)` with `capacity = total_supply`[cite: 175].
6.  **Demand Calculation**: We sum all capacities on all edges leaving `s*` to get a `total_demand_to_meet`.

### 3. Feasibility & Infeasibility

* **Feasibility Check**: A single max-flow is run from `s*` to `t*`. [cite_start]The flow is **feasible if and only if** the resulting `max_flow` value is equal (within tolerance) to the `total_demand_to_meet`[cite: 195]. This single check validates all lower bounds, node caps, and supply/demand at once.
* [cite_start]**Infeasibility Certificate**: If the flow is less than the demand, the problem is infeasible[cite: 169].
    * [cite_start]A **min-cut** is computed on the graph using `nx.minimum_cut`[cite: 265].
    * [cite_start]The `cut_reachable` set is the set of nodes reachable from `s*` in the residual graph (one side of the partition)[cite: 234].
    * [cite_start]The `deficit` is `total_demand_to_meet - max_flow`[cite: 221].

### 4. Flow Reconstruction

[cite_start]If feasible, the flow on an original edge `(u, v)` is `f' + lo`, where `lo` is the original lower bound [cite: 189] and `f'` is the flow on the transformed edge `(map_out(u), map_in(v))` found by the `maximum_flow` algorithm.

---

## Numeric Approach & Edge Cases

* [cite_start]**Numeric Tolerance**: A standard tolerance of `1e-9` is used for all floating-point comparisons[cite: 154, 239], such as checking LP constraint slacks, flow feasibility, and intermediate item balance.
* [cite_start]**Determinism**: Determinism is guaranteed by the underlying solvers[cite: 157, 250]. `pulp`'s default `CBC` solver is deterministic. `networkx`'s `maximum_flow` and `minimum_cut` algorithms are also deterministic.
* **Failure Modes**:
    * [cite_start]**Infeasible Raw Supplies**: `factory` will be "Infeasible" and the `find_max_rate` LP will identify the tight raw supply constraint as a bottleneck[cite: 272].
    * [cite_start]**Redundant Recipes**: The `factory` LP will *automatically* choose the most machine-efficient recipe(s) due to the "minimize total machines" objective[cite: 273].
    * [cite_start]**Disconnected Graph (Belts)**: If a source cannot reach the sink, its required flow won't be met[cite: 274]. The `s*` to `t*` flow will not saturate, and the `min-cut` will correctly identify the disconnected component as the source-side of the cut.